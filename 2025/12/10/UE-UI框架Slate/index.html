<!DOCTYPE html>
<html 
	lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		
<link rel="stylesheet" href="/css/layout.css">

		
		<title> UE-UI框架Slate{0}-UI设计及Slate的机制 -  LL&#39;s Blog</title>
		<!-- <link rel="stylesheet" href="https://unpkg.com/mdui@1.0.2/dist/css/mdui.min.css" /> -->
		<!-- <script src="https://unpkg.com/mdui@1.0.2/dist/js/mdui.min.js"></script> -->
		
<link rel="stylesheet" href="/lib/mdui/mdui.min.css">

		
<script src="/lib/mdui/mdui.min.js"></script>

		<!-- lazyload -->
		
<script src="/lib/lazysizes.js"></script>

		<!-- smooth-scrolling -->
		
<script src="/lib/smooth-scrolling.js"></script>

		<!-- highlight -->
		
<link rel="stylesheet" href="/lib/highlight/atom-one-dark.min.css">

		
<script src="/lib/highlight/highlight.min.js"></script>

		<!-- 预置 kiraicon -->
		
<link rel="stylesheet" href="/lib/iconfont/iconfont.css">

		
		<link
			rel="shortcut icon"
			href="/1.png"
			type="image/png"
		/>
		
<link rel="stylesheet" href="/deps/css/APlayer.min.css">

		
			
				
<link rel="stylesheet" href="/custom.css">

			
		
		
<script src="/deps/js/APlayer.min.js"></script>
<script src="/deps/js/Meting.min.js"></script>

	<meta name="generator" content="Hexo 7.3.0"></head>

	<body>
		<div
			class="kira-background"
			style="background-image: url('/lib/background/bg5.jpg')"
		></div>
		<div class="kira-header">
    <a
        class="kira-drawer-button mdui-ripple"
        title="导航栏"
        onclick="document.querySelector('.kira-sidebar-modal').classList.add('show');document.querySelector('.kira-sidebar#sidebar').classList.add('show');"
    >
        <i class="kirafont icon-menu"></i>
    </a>
    <a href="/" title="LL&#39;s Blog">
        <img
			src="/1.png"
			alt="Lzorn"
		/>
    </a>
</div>
		<div class="kira-body">
			<div class="kira-sidebar" id="sidebar">
	<div class="kira-avatar mdui-ripple">
		<a href="/1.png" title="Lzorn">
			<img
				src="/1.png"
				alt="Lzorn"
			/>
		</a>
	</div>
	<div class="kira-count">
		<div><span>文章</span>4</div>
		<div><span>标签</span>2</div>
		<div><span>分类</span>3</div>
	</div>
	<div class="kira-list">
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/"
			title="回到首页"
		>
			<i
				class="kirafont
					
						icon-home
					"
			></i>
			<div class="kira-list-item-content">
				回到首页
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/archive.html"
			title="文章归档"
		>
			<i
				class="kirafont
					
						icon-container
					"
			></i>
			<div class="kira-list-item-content">
				文章归档
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/about.html"
			title="关于本人"
		>
			<i
				class="kirafont
					
						icon-user
					"
			></i>
			<div class="kira-list-item-content">
				关于本人
			</div>
		</a>
		
	</div>
	<aside id="kira-sidebar">
		
			<div class="kira-widget-wrap">
	<div class="kira-widget kira-social">
		
			<a
				class="mdui-ripple"
				href="mailto:your-email@example.com"
				target="_blank"
				mdui-tooltip="{content: '邮箱'}"
				style="color: rgb(255, 87, 34); background-color: rgba(255, 87, 34, .15);"
			>
				<i
					class="kirafont
					
						icon-link
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://space.bilibili.com/13063107"
				target="_blank"
				mdui-tooltip="{content: '哔哩哔哩'}"
				style="color: rgb(231, 106, 141); background-color: rgba(231, 106, 141, .15);"
			>
				<i
					class="kirafont
					
						icon-bilibili
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://github.com/lzorn-lzorn/"
				target="_blank"
				mdui-tooltip="{content: 'GitHub'}"
				style="color: rgb(25, 23, 23); background-color: rgba(25, 23, 23, .15);"
			>
				<i
					class="kirafont
					
						icon-github
					"
				></i>
			</a>
		
	</div>
</div>

		
			
  <div class="kira-widget-wrap">
    <h3 class="kira-widget-title">分类</h3>
    <div class="kira-widget">
      <ul class="category-list">
        
        

        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/Hexo/">
              Hexo
            </a>
            <span class="category-list-count">1</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/UE/">
              UE
            </a>
            <span class="category-list-count">3</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/UE/UE-UI/">
              UE-UI
            </a>
            <span class="category-list-count">3</span>
          </li>
        
      </ul>
    </div>
  </div>

		
			
	<div class="kira-widget-wrap">
		<div id="randomtagcloud" class="kira-widget tagcloud kira-rainbow">
			<a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/UE/" style="font-size: 10px;">UE</a>
		</div>
		
	</div>


		
			
	<div class="kira-widget-wrap">
		<h3 class="kira-widget-title">
			Archive
		</h3>
		<div class="kira-widget">
			<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/">2025</a><span class="archive-list-count">4</span></li></ul>
		</div>
	</div>


		
	</aside>
	<div class="kira-copyright">
		&copy; 2025
		<a href="/">Lzorn</a>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> &
		<a href="https://github.com/ch1ny/kira-hexo/" target="_blank">Kira-Hexo</a>
		<br />
		
		
	</div>
</div>
<div
	class="kira-sidebar-modal"
	id="sidebar-modal"
	onclick="(function(self) {
		self.classList.remove('show');
		document.querySelector('.kira-sidebar.show#sidebar').classList.remove('show');
	})(this)"
></div>
			<div class="kira-content">
				<div id="kira-top-header"></div>
				<div class="kira-main-content">
					
<link rel="stylesheet" href="/css/kira-image.css">


<script src="/js/kira-image.js"></script>

<div class="kira-image">
    <div class="kira-image-modal">
        <div class="kira-image-header">
            <div class="kira-image-counter"></div>
            <div class="kira-image-title"></div>
            <div class="kira-image-operation">
                <div class="kira-image-operation-button" id="kira-image-operation-button-zoom">
                    <i class="kirafont icon-zoom-in"></i>
                </div>
                <div class="kira-image-operation-button" id="kira-image-operation-button-close">
                    <i class="kirafont icon-close"></i>
                </div>
            </div>
        </div>
        <div class="kira-image-container">
            <div class="kira-image-prev-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-left"></i>
                </div>
            </div>
            <div class="kira-image-list">
                <div class="kira-image-prev">
                    <img />
                </div>
                <div class="kira-image-now">
                    <img />
                </div>
                <div class="kira-image-next">
                    <img />
                </div>
            </div>
            <div class="kira-image-next-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-right"></i>
                </div>
            </div>
        </div>
    </div>
</div>

	
<link rel="stylesheet" href="/css/kira-code-copy.css">

	
<script src="/js/kira-code-copy.js"></script>


<div class="kira-post">
	<article>
		
		<div class="kira-post-cover">
			<img
				data-src="/lib/background/bg3.jpg"
				data-sizes="auto"
				alt="UE-UI框架Slate{0}-UI设计及Slate的机制"
				class="lazyload kira-post-cover-image disabled-kira-image"
			/>
			<h1>UE-UI框架Slate{0}-UI设计及Slate的机制</h1>
		</div>
		
		<div class="kira-post-meta kira-rainbow" style="margin:10px 0!important;">
			<a><i class="kirafont icon-calendar-fill"></i>2025年12月10日</a>
			<a><i class="kirafont icon-edit-fill"></i>3.5k 字</a>
			<a><i class="kirafont icon-time-circle-fill"></i>大概 15 分钟</a>
		</div>
		<!-- toc --><html><head></head><body><ul>
<li><a href="#ue%E7%9A%84ui%E6%A1%86%E6%9E%B6-slate">UE的UI框架-Slate</a></li>
<li><a href="#ui%E7%AA%97%E5%8F%A3%E7%9A%84%E7%BB%84%E7%BB%87swindow">UI窗口的组织SWindow</a></li>
<li><a href="#%E7%AA%97%E5%8F%A3%E7%9A%84%E6%B8%B2%E6%9F%93">窗口的渲染</a></li>
<li><a href="#ui%E7%AA%97%E5%8F%A3%E7%9A%84%E7%BB%84%E7%BB%87swindow-1">UI窗口的组织SWindow</a></li>
<li><a href="#%E7%AA%97%E5%8F%A3%E7%9A%84%E6%B8%B2%E6%9F%93-1">窗口的渲染</a><ul>
<li><a href="#%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C%E7%9A%84%E5%85%A5%E5%8F%A3-%E6%A8%A1%E6%80%81%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6">渲染执行的入口-模态窗口机制</a></li>
<li><a href="#%E5%AF%B9%E4%BA%8E%E6%B8%B2%E6%9F%93%E7%9A%84%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C-%E5%BF%AB%E6%85%A2%E8%B7%AF%E5%BE%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B">对于渲染的数据操作-快慢路径绘制流程</a></li>
<li><a href="#widget%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-%E5%A4%B1%E6%95%88%E6%9C%BA%E5%88%B6invalidate">Widget的渲染流程: 失效机制(Invalidate)</a></li>
<li><a href="#%E5%AE%9E%E9%99%85%E7%9A%84%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8draw-call">实际的绘制调用(Draw-Call)</a></li>
</ul>
</li>
<li><a href="#%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94">窗口的事件响应</a><ul>
<li><a href="#%E5%B1%8F%E5%B9%95%E7%BD%91%E6%A0%BC">屏幕网格</a></li>
<li><a href="#slate%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94">Slate的事件响应</a></li>
</ul>
</li>
<li><a href="#%E6%8E%A7%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%BB%E8%BE%91%E7%9A%84%E5%85%B3%E7%B3%BB">控件之间的逻辑的关系</a><ul>
<li><a href="#%E6%8E%A7%E4%BB%B6%E6%A0%91%E6%9C%BA%E5%88%B6">控件树机制</a></li>
</ul>
</li>
<li><a href="#%E6%8E%A7%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB">控件之间的位置关系</a><ul>
<li><a href="#ui-%E6%89%A9%E5%B1%95%E7%82%B9">UI 扩展点</a></li>
<li><a href="#slot">Slot</a></li>
<li><a href="#geometry">Geometry</a></li>
</ul>
</li>
<li><a href="#ue%E7%9A%84%E6%B8%B8%E6%88%8Fui-umg">UE的游戏UI-UMG</a></li>
</ul>
<!-- tocstop -->

<h1><span id="ue%E7%9A%84ui%E6%A1%86%E6%9E%B6-slate">UE的UI框架-Slate</span></h1><p>UE 使用 C++ 实现了自己原生的一套UI界面, 这里的 C++ 是纯C++ 并不是使用了 UObject 的C++, 原因是 UObject 系统对于要求流程丝滑的 UI 界面而已太过沉重. 但是对于游戏中用户界面又必须要被整个GC所接管, 例如玩家的血条, 这里的血条控件应该和玩家单位使用同一套回收机制. 所以 UE 使用一个继承自 UObject 的类去包裹 Slate 的对象, 即 UMG 对象. 换句话说, UMG 对象只是 Slate 对象的容器, 真正的逻辑都执行在 Slate 的基础控件中.</p>
<p><code>FSlateApplication</code> 是 Slate 系统的入口. <code>FEngineLoop::Tick</code> 通过 <code>FSlateApplication::Tick</code> 渲染 Slate 已经执行其逻辑</p>
<p>在 UI 设计中, 有一些问题是无法绕过的:</p>
<ol>
<li>窗口之间的关系如何组织</li>
<li>窗口内的各种控件的关系如何组织</li>
<li>具体窗口和控件的渲染如何处理</li>
<li>窗口如何进行事件响应</li>
</ol>
<p>接下来会一一说明</p>
<h1><span id="ui%E7%AA%97%E5%8F%A3%E7%9A%84%E7%BB%84%E7%BB%87swindow">UI窗口的组织SWindow</span></h1><p>窗口是一个典型的树结构, <code>SWindow</code> 中存有一个父类的弱引用(<code>TWeakPtr&lt;SWindow&gt; ParentWindowPtr;</code>), 同时存有所有子窗口的共享应用(<code>TArray&lt;TSharedRef&lt;SWindow&gt;&gt; ChildWindows;</code>). <code>FSlateApplication</code> 中管理了所有顶窗口, 即没有父窗口的窗口(<code>TArray&lt;TSharedRef&lt;SWindow&gt;&gt; SlateWindows;</code>)</p>
<h1><span id="%E7%AA%97%E5%8F%A3%E7%9A%84%E6%B8%B2%E6%9F%93">窗口的渲染</span></h1><h1><span id="ui%E7%AA%97%E5%8F%A3%E7%9A%84%E7%BB%84%E7%BB%87swindow">UI窗口的组织SWindow</span></h1><p>窗口是一个典型的树结构, <code>SWindow</code> 中存有一个父类的弱引用(<code>TWeakPtr&lt;SWindow&gt; ParentWindowPtr;</code>), 同时存有所有子窗口的共享应用(<code>TArray&lt;TSharedRef&lt;SWindow&gt;&gt; ChildWindows;</code>). <code>FSlateApplication</code> 中管理了所有顶窗口, 即没有父窗口的窗口(<code>TArray&lt;TSharedRef&lt;SWindow&gt;&gt; SlateWindows;</code>)</p>
<h1><span id="%E7%AA%97%E5%8F%A3%E7%9A%84%E6%B8%B2%E6%9F%93">窗口的渲染</span></h1><h2><span id="%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C%E7%9A%84%E5%85%A5%E5%8F%A3-%E6%A8%A1%E6%80%81%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6">渲染执行的入口-模态窗口机制</span></h2><p>Slate 中渲染每一个 <code>SWindows</code> 大致分为两个主要阶段: 数据处理阶段, 实际渲染 Draw-Call 的调用.<br>Slate 中主要负责的是前者, 换句话说, Slate 只是负责处理窗口的各种数据, 实际的渲染会派发给渲染器(SlateRender), 其实际调用是:<br><code>FEngineLoop::Tick</code><br>-&gt; <code>FSlateApplication::Tick</code><br>-&gt; <code>FSlateApplication::TickAndDrawWidgets</code><br>-&gt; <code>FSlateApplication::DrawWindows</code><br>从 <code>FSlateApplication::DrawWindows</code> 这个函数开始, 正式进入渲染的流程, 如下图</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/./images/UE-UI%E7%9A%84%E6%B8%B2%E6%9F%93%E5%85%A5%E5%8F%A3.png" alt="UE-UI的渲染入口" class="lazyload"></p>
<p>在这里设计到一个概念: <font color="#c0504d">模态窗口(Modal Window)</font>, 这个是一个在UI设计中常用的概念: 其是一种特殊的用户界面元素, 当它被激活时, 会阻止用户与应用程序的其他部分进行交互, 直到用户完成当前操作并关闭该窗口. 也就是强制用户进行完当前操作. </p>
<p>在 WPF 中 <code>ShowDialog</code> 就是一种模态窗口; 在 Qt 中也可以调用 <code>QDialog</code> 中的 <code>setModal</code>, 来设置其模态属性; 在 Electron 中, </p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> modal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrowserWindow</span>({<br>  <span class="hljs-attr">parent</span>: mainWindow,  <span class="hljs-comment">// 设置父窗口</span><br>  <span class="hljs-attr">modal</span>: <span class="hljs-literal">true</span>,         <span class="hljs-comment">// 设置为模态</span><br>  <span class="hljs-attr">show</span>: <span class="hljs-literal">false</span><br>});<br></code></pre></td></tr></tbody></table></figure>
<p>也可以设置 modal 属性. </p>
<p>所以, 在渲染时, Slate 会优先渲染模态窗口. 在整个渲染的入口中, 所有的步骤都是在处理 <code>DrawWindowArgs.OutDrawBuffer</code> 并使其可以达到可以被渲染器直接使用的程度.</p>
<p>在实际渲染数据处理的过程中, 有两个阶段:</p>
<ol>
<li>预处理: <code>DrawPrepass()</code> 其目的主要是处理窗口和控件的各种尺寸</li>
<li>正式进行渲染数据的处理: <code>DrawWindowAndChildren()</code></li>
</ol>
<h2><span id="%E5%AF%B9%E4%BA%8E%E6%B8%B2%E6%9F%93%E7%9A%84%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C-%E5%BF%AB%E6%85%A2%E8%B7%AF%E5%BE%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B">对于渲染的数据操作-快慢路径绘制流程</span></h2><p>对于正在进行渲染数据的处理流程: 如下图<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./images/%E6%B8%B2%E6%9F%93%E5%8D%95%E4%B8%AA%E7%AA%97%E5%8F%A3%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C.png" alt="渲染单个窗口进行数据操作.png" class="lazyload"><br>这里出现了第二个概念: <font color="#c0504d">快路径渲染和慢路径渲染</font>, 同时需要介绍UE这里的缓存机制: UI 框架为了优化渲染性能, 尽可能减少渲染次数, 在很多时候不会对窗口进行重新绘制, 而是采用缓存中已有的数据进行渲染, 这就是快路径渲染. 而对于缓存实效的情况, 则需要按照正常流程渲染窗口, 子窗口, 以及控件, 也就是慢路径渲染, 所以只有在慢路径渲染的情况下才会去重新调用控件的 <code>OnPaint()</code> 方法.<br>更详细的来说: 慢路径渲染是一次完整的, 保守的从根到叶的遍历——重新评估布局/可见性/几何, 重建/绘制每个 widget, 更新 hit-test 网格, 并重建或刷新绘制元素缓存(CachedElementData). 它保证在任何结构性或状态变化后画面正确, 但开销大; 而快路径绘制是在没有结构性变化时尽量”重用上帧结果”, 只做必要更新(Eg: 几何/变换、剪裁、z 层调整、对少量”最终更新” widget 的重绘、以及同步 hit-test)</p>
<h2><span id="widget%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-%E5%A4%B1%E6%95%88%E6%9C%BA%E5%88%B6invalidate">Widget的渲染流程: 失效机制(Invalidate)</span></h2><p>在每帧渲染时会检查失效状态, 如果调用了 <code>SetVisibility()</code>, <code>SetRenderTransform()</code> 等函数则会触发失效检查, 会在控件内部调用 <code>Invalidate(Reason)</code>, 然后触发控件的重新绘制, 但是并不是所有的重绘都要重新走一边流程, 在UE中由以下失效理由:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">EInvalidateWidgetReason</span> : uint8<br>{<br>    None = <span class="hljs-number">0</span>, <span class="hljs-comment">// 不需要任何无效化</span><br>    Layout = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>,<br>    Paint = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>,<br>    Volatility = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>,<br>    ChildOrder = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>,<br>    RenderTransform = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>,<br>    Visibility = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>,<br>    AttributeRegistration = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>,<br>    Prepass = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>,<br>    PaintAndVolatility = Paint | Volatility,<br>    LayoutAndVolatility = Layout | Volatility,<br>};<br></code></pre></td></tr></tbody></table></figure>
<p>其中: </p>
<ul>
<li><code>Layout</code>: 则会触发重布局-则会对控件进行重新测量, 重新准备数据, 重新绘制, 是开销最大的一种 <code>Reason</code>. 但是如果控件的位置变化, 大小变化, 排列变化(Padding, Slot 这种参数变化), 则必须重布局</li>
<li><code>Paint</code>: 表示控件需要重新绘制，但不会影响布局(例如: Icon的颜色变了吗, 文本颜色变了, 仅视觉内容不同)</li>
<li><code>Volatility</code> 表示波动性: 如果一个控件被设置为 <code>Volatility</code> 则其会每帧调用 <code>Paint</code> 重新绘制, 如果没有设置为 <code>Volatility</code> 的控件, 则会复用其缓存的信息. (动画控件，或Tick频繁变内容的控件), 由于控件由原来的静态变为动态, 会影响 <code>RenderBatch</code></li>
<li><code>ChildOrder</code>: 子控件被增加或删除(如Panel子项变动). 属于重布局的变动，隐含触发 Prepass/Layout</li>
<li><code>RenderTransform</code>: 控件的Render变换(位置、旋转、缩放等), 发生变化. <u>只影响控件渲染, 影响布局</u>.</li>
<li><code>Visibility</code>: 可见性变化(Visible/Collapsed/Hidden)通常需要<u>重布局</u>, 因为不可见控件不再占空间<ul>
<li>Collapsed: 必然重布局的, 不占据任何布局空间, 等价于在树里将节点从Panel的子集合中临时移除那样的效果</li>
<li>Hidden: 只是重绘, 不会强制触发重布局( ==todo==: 待验证, 断不到源码位置)</li>
</ul>
</li>
<li><code>AttributeRegistration</code>: 属性的绑定/解绑变化(SlateAttribute绑定/解绑)时触发. 用于属性反射或Slate绑定机制内部处理</li>
<li><code>Prepass</code>: <u>递归强制</u>重走子树的Prepass(递归更新DesiredSize), 一般用于布局大幅改变或子节点数巨变，需要全部节点自下而上检查尺寸, 比 <code>Layout</code> 还消耗性能</li>
</ul>
<p>如果父控件失效了, 则其失效标记会扩散到子控件. 对于一些经常变化颜色和UI动画应该设置 <code>Volatility</code> 往往是比较保险的</p>
<p>在UE的UI中还有常见的两种优化策略:</p>
<ul>
<li>合批优化: 其本质是, 对于满足一些条件UI元素进行合并 Draw-Call, 可以只使用一次 Draw-Call 来批量绘制UI元素. 具体见后 {UE-UI框架Slate-2-Slate的监控和优化}</li>
<li>重绘盒优化: 具体见后 {UE-UI框架Slate-2-Slate的监控和优化}</li>
</ul>
<h2><span id="%E5%AE%9E%E9%99%85%E7%9A%84%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8draw-call">实际的绘制调用(Draw-Call)</span></h2><p>最后, 实际上真正向GPU提交绘制命令并不在Slate层中, FSlateApplication 将所有数据准备好之后, 在 <code>FSlateApplication::PrivateDrawWindows</code> 中调用 <code>Renderer-&gt;DrawWindows</code><br>最后进入 <code>SlateRHIRender::DrawWindow_RenderThread</code> 中调用 <code>FRHICommandList::BeginDrawingViewport</code> (RHICmdList) -&gt;<br><code>FRHICommandList::RHIBeginDrawingViewport</code> (GetContext()), 进入真实运行的在当前系统的 RenderDynamicRHI 封装中 -&gt;<br><code>FRHICommandList::BeginRenderPass</code> (RHICmdList) -&gt;<br><code>FSlateRHIRenderingPolicy::DrawElements</code> (RenderingPolicy) 内部会设置各种和渲染有关的细节(Eg: 顶点着色器, 像素着色器, 纹理, 渲染资源), 其中每一次对 <code>FRHICommandList::DrawIndexedPrimitive</code> 的调用就是一次 DrawCall, 具体流程如下:<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./images/%E5%AE%9E%E9%99%85%E7%9A%84%E6%B8%B2%E6%9F%93Draw-Call.png" alt="实际的渲染Draw-Call" class="lazyload"><br>更详细的来说, GPU(同时包括渲染API)只是渲染最基础的各种图元和定点信息和片段信息, 而这些信息会在之前的 SlateApplication 阶段就基本已经处理好, 在 Render 中只是将这些基本的 WindowElement 转化为顶点数据和片段数据(像素数据), 由于UE对各种渲染API的封装, 所以不必关心具体的渲染细节, 例如: 在 Vulkan 中实际上已经没有 VBO, EBO这种结构, 已经被 Vulkan 抽象为一个缓冲区等.</p>
<h1><span id="%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94">窗口的事件响应</span></h1><h2><span id="%E5%B1%8F%E5%B9%95%E7%BD%91%E6%A0%BC">屏幕网格</span></h2><p>屏幕网格结构 <code>FHittestGrid</code>: 其内部有保有 <code>FCell</code> (本质上持有一个SWideget的句柄数组 <code>TArray&lt;int32&gt; WidgetIndexes</code>)<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./images/FHittestGrid.png" alt="FHittestGrid示意图" class="lazyload"></p>
<h2><span id="slate%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94">Slate的事件响应</span></h2><p>Slate 系统的用于处理用户输入的类为 FSlateUser(不仅能处理输入)<br><code>FSlateUser</code> 表示一个逻辑上的用户/输入上下文(包含指针位置、捕获、焦点路径、tooltip 状态、drag-drop 状态等), 一个 <code>FSlateUser</code> 会管理一个或多个指针索引（鼠标、触摸点等）以及与该用户相关的状态, 手柄会控制光标和指针, 所以插入手柄会增加一个 <code>FSlateUser</code>, 但是并不是随便插入一个交互设备就能添加一个 <code>FSlateUser</code>. 其主要负责 Cursor (光标):</p>
<ul>
<li>Focus: 聚焦</li>
<li>Capture: 捕获</li>
<li>DragDrop: 拖动</li>
<li>Draw: 绘制<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/j756915370/article/details/121964442">Slate 的事件响应</a></li>
</ul>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/./images/%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E6%B5%81%E7%A8%8B.png" alt="点击事件响应流程.png" class="lazyload"></p>
<h1><span id="%E6%8E%A7%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%BB%E8%BE%91%E7%9A%84%E5%85%B3%E7%B3%BB">控件之间的逻辑的关系</span></h1><p>Slate 中基类是 <code>SWidget</code>, 继承 <code>SWidget</code> 的有另外三个基础类:</p>
<ul>
<li><code>SPanel</code>&nbsp;: 有多个子节点</li>
<li><code>SLeafWidget</code>&nbsp;: 没有子节点</li>
<li><code>SCompoundWidget</code>&nbsp;: 可以有一个子节点</li>
</ul>
<h3><span id="%E6%8E%A7%E4%BB%B6%E6%A0%91%E6%9C%BA%E5%88%B6">控件树机制</span></h3><p>控件树: 在UI设计中, 窗口之间的逻辑关系是一种树关系, 在不同的系统中使用到了不同的方式来组织管理控件树<br><code>FWidgetPath</code> 是对于控件树的垂直切片(vertical slice), 是从某一个节点A开始到另一个可达子节点B路径的表示. <code>FArrangedChildren</code> 是内部的容器表示, 内部存有 <code>FArrangedWidget</code> (保有控件指针 <code>TSharedRef&lt;SWidget&gt;</code> 和 位置信息 <code>FGeometry</code>)<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./images/FWidgetPath.png" alt="FWidgetPath" class="lazyload"></p>
<h1><span id="%E6%8E%A7%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB">控件之间的位置关系</span></h1><h2><span id="ui-%E6%89%A9%E5%B1%95%E7%82%B9">UI 扩展点</span></h2><p>UI 扩展点: 是引擎预先定义好的一些控件插入的位置 (编辑器偏好设置 &gt; 其他 &gt; 开发者工具 &gt; 显示UI扩展点 &gt; true/Editor Preference &gt; General &gt; Miscellaneous &gt; Developer Tools &gt; Display UI Extension Pointers &gt; true. 开启之后就可以看到对应的扩展点的名字)<br>UE Editor 中常用的两种 UI 位置: ToolBar 和 Menu, 往往我们的新加入的编辑器功能总是会加入这两类位置<br>一个UI控件扩展对应了源码中的 <code>FExtender</code>, 以下代码对应了申请的扩展点</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Cpp">TSharedPtr&lt;FExtender&gt; MenuExtender = <span class="hljs-built_in">MakeShareable</span>(<span class="hljs-keyword">new</span> FExtender);<br><span class="hljs-comment">// 添加一个扩展行为</span><br>MenuExtender-&gt;<span class="hljs-built_in">AddMenuExtension</span>(<br>    <span class="hljs-string">"HelpApplication"</span>,  <span class="hljs-comment">// 扩展点</span><br>    EExtensionHook::After, <span class="hljs-comment">// 扩展的位置, 在 "HelpApplication" 之后</span><br>    PluginCommands, <span class="hljs-comment">// 命令集 FUICommandList</span><br>    <span class="hljs-comment">// 创建委托, 绑定函数 FMyEditorToolsModule::AddMenuExtension 创建按钮</span><br>    FMenuExtensionDelegate::<span class="hljs-built_in">CreateRaw</span>(<span class="hljs-keyword">this</span>, &amp;FMyEditorToolsModule::AddMenuExtension)<br>);<br></code></pre></td></tr></tbody></table></figure>
<p>其中 <code>FMyEditorToolsModule::AddMenuExtension</code> 是一个约定好的回调函数, 其接收一个 Builder, 由 Builder 来负责添加对应的 Entry.<br>这里实际上是一个职责分离的设计: 添加扩展是使用 Builder 来添加, 更加添加的位置不同, 使用 Builder 也不同, 但是大体来说常用只有 <code>FMenuBuilder</code> 和 <code>FToolBarBuilder</code>, 同时具体点击触发的逻辑是由之前绑定好的 <code>FCommandList</code> 的来决定的 (<code>MapAction</code> 接口), Builder 中的 Begin/End Section 中的 Section 就是一个扩展点. </p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FMyEditorToolsModule::AddMenuExtension</span><span class="hljs-params">(<span class="hljs-keyword">class</span> FMenuBuilder&amp; builder)</span></span>{<br>    builder.<span class="hljs-built_in">BeginSection</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">"MyButton"</span>));<br>    <span class="hljs-comment">// 绑定回调 PluginAction-&gt; FExcuteAction::CreateRaw(this, &amp;FMyEditorToolsModule::PluginButtonClicked); </span><br>    <span class="hljs-comment">// -&gt; FMyEditorToolsModule::PluginButtonClicked</span><br>    builder.<span class="hljs-built_in">AddMenuEntry</span>(FMyEditorToolbarButtonCommands::<span class="hljs-built_in">Get</span>().PluginAction);<br>    <span class="hljs-comment">// 在一开始的时候绑定了命令集</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">           PluginCommands-&gt;MapAction(</span><br><span class="hljs-comment">                FMyUICommands::Get().PluginAction,</span><br><span class="hljs-comment">                // 绑定回调</span><br><span class="hljs-comment">                FExcuteAction::CreateRaw(this, &amp;FMyEditorToolsModule::PluginButtonClicked); </span><br><span class="hljs-comment">                // 是否可以执行回调</span><br><span class="hljs-comment">                FCanExecuteAction()</span><br><span class="hljs-comment">                // 可选 FIsActionChecked 等回调用于 Toggle/Check 类型</span><br><span class="hljs-comment">            );</span><br><span class="hljs-comment">    */</span><br>    builder.<span class="hljs-built_in">EndSection</span>();<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>在UE Editor 中有很多模块: 动画蓝图模块 <code>IAnimationBlueprintEditorModule</code>, 蓝图编辑器模块 <code>FBlueprintEditorModule</code>, 但是并不是所有模块都是可以扩展的, 同时如果该模块支持扩展菜单栏则会继承 <code>IHasMenuExtensibility</code> , 如果该支持扩展工具栏则会继承 <code>IHasToolBarExtensibility</code></p>
<h2><span id="slot">Slot</span></h2><p>在 UE 的UI中, 有的控件是可以添加子控件的, 如何描述子控件在本控件的各种位置, 就是通过 Slot (槽) 来进行指定的. 对于不同的控件, 一般都有自己的专属的 Slot, 所以这些 Slot 往往都会以内部类声明的方式出现, 同时继承个各种接口</p>
<h2><span id="geometry">Geometry</span></h2><p>Slot 提供了子控件位置信息说明, Geometry 则是通过 Slot 提供的信息最终计算出来的实际坐标. 每一帧会触发布局计算, 然后从根控件开始, 每次调用 <code>OnArrangeChildren</code> 进行空间的递归分配位置和空间, 然后对于每一个 Slot 解析其参数, 最后确定每一个Widget的大小和坐标, 为其他系统提供准备 (渲染, 碰撞, 输入)</p>
<h1><span id="ue%E7%9A%84%E6%B8%B8%E6%88%8Fui-umg">UE的游戏UI-UMG</span></h1><p>Slate 是纯使用C++实现的轻量级框架, 但是在游戏中显示UI是实实在在的游戏内对象. 所以 UMG 本质上是使用 UObject 对Slate 控件的一种封装.<br>所以 UMG 控件和 Slate 的控件是对应的, 当我们想设计自己的 Slate 控件时, 可以在 UMG 界面设计完成之后, 统一翻译成 Slate 的声明式语法</p>

    <div id="global-aplayer"></div>
    <script>
      if (typeof APlayer !== 'undefined') {
        const ap = new APlayer({
          container: document.getElementById('global-aplayer'),
          fixed: true,
          mini: true,
          autoplay: false,
          theme: '#FF6347',
          loop: 'all',
          order: 'list',
          preload: 'auto',
          volume: 0.4,
          mutex: true,
          listFolded: false,
          listMaxHeight: 200,
          audio: [
            {
              name: '魔法使いの夜～メインテーマ',
              artist: '深澤秀行',
              url: '/music/magic-night.mp3',
              cover: '/music/cover.jpg',
              lrc: '/music/magic-night.lrc'
            }
          ]
        });
      }
    </script>
  </body></html>
	</article>

	 
    <div class="kira-post-copyright">
        <strong>Author：</strong>Lzorn<br>
        <strong>Link：</strong><a href="http://example.com/2025/12/10/UE-UI%E6%A1%86%E6%9E%B6Slate/" title="http:&#x2F;&#x2F;example.com&#x2F;2025&#x2F;12&#x2F;10&#x2F;UE-UI框架Slate&#x2F;" target="_blank" rel="noopener">http:&#x2F;&#x2F;example.com&#x2F;2025&#x2F;12&#x2F;10&#x2F;UE-UI框架Slate&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>

  
	<div class="kira-post-nav">
		<nav class="post-nav">
			        
			<!-- 先找到与当前文字相同的目录 -->
			   
			<!-- 在找到当前文章所在的 index -->
			       
			<!-- 下一篇文章 -->
			<div class="new">
				<span>下一章</span>
				<a href="/2025/12/10/UE-UI%E6%A1%86%E6%9E%B6Slate-1-%E4%BD%BF%E7%94%A8Slate%E6%89%A9%E5%B1%95UI/"> UE-UI框架Slate{1}-使用Slate扩展UI</a>
			</div>
			                       
			<!-- 先找到与当前文字相同的目录 -->
			   
			<!-- 在找到当前文章所在的 index -->
			       
			<!-- 下一篇文章 -->
			<div class="new">
				<span>下一章</span>
				<a href="/2025/12/10/UE-UI%E6%A1%86%E6%9E%B6Slate-1-%E4%BD%BF%E7%94%A8Slate%E6%89%A9%E5%B1%95UI/"> UE-UI框架Slate{1}-使用Slate扩展UI</a>
			</div>
			                 
		</nav>
	</div>
	
	<div class="kira-post-meta kira-rainbow">
		
			<a class="kirafont icon-container-fill -link" href="/categories/UE/">UE</a><a class="kirafont icon-container-fill -link" href="/categories/UE/UE-UI/">UE-UI</a>
		
		
			<a class="kirafont icon-tag-fill -none-link" href="/tags/C/" rel="tag">C++</a> <a class="kirafont icon-tag-fill -none-link" href="/tags/UE/" rel="tag">UE</a>
		
	</div>
	
	<div class="kira-post-footer">
		

		
	</div>
	
</div>

				</div>
			</div>
			<div class="kira-right-column">
	<a onclick="document.querySelector('#kira-top-header').scrollIntoView({behavior: 'smooth'});" class="kira-backtotop" aria-label="回到顶部" title="回到顶部">
		<button class="mdui-fab mdui-ripple">
			<i class="kirafont icon-caret-up"></i>
		</button>
	</a>
</div>

		</div>
	</body>
</html>
